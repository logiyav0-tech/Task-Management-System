import jsPDF from 'jspdf';
import 'jspdf-autotable';

/**
 * Professional CSV Export Utility
 */
export const exportToCSV = (tasks, filename, currentUser) => {
    // CSV headers
    const headers = [
        'Task Name',
        'Category',
        'Department',
        'Status',
        'Priority',
        'Responsible Person',
        'Start Date',
        'End Date',
        'Completion %',
        'Remarks',
        'Last Modified By',
        'Last Modified At'
    ];

    // Convert tasks to CSV rows
    const csvRows = tasks.map(task => [
        `"${task.taskName || ''}"`,
        `"${task.category || 'General'}"`,
        `"${task.department || 'Production'}"`,
        `"${getStatusLabel(task.status)}"`,
        `"${getPriorityLabel(task.priority)}"`,
        `"${task.responsible || 'Unassigned'}"`,
        `"${formatDateForExport(task.startDate)}"`,
        `"${formatDateForExport(task.endDate)}"`,
        `"${task.completionPercentage || 0}%"`,
        `"${(task.remarks || '').replace(/"/g, '""')}"`, // Escape quotes in remarks
        `"${task.lastModifiedBy || 'N/A'}"`,
        `"${formatDateTimeForExport(task.lastModifiedAt)}"`
    ]);

    // Create CSV content
    const csvContent = [
        headers.join(','),
        ...csvRows.map(row => row.join(','))
    ].join('\n');

    // Create and download file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};

/**
 * Professional PDF Export Utility
 */
export const exportToPDF = (tasks, filename, currentUser, summary) => {
    const doc = new jsPDF();
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    
    // Add header
    doc.setFillColor(41, 128, 185);
    doc.rect(0, 0, pageWidth, 30, 'F');
    
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(20);
    doc.setFont('helvetica', 'bold');
    doc.text('TASK MANAGEMENT REPORT', pageWidth / 2, 15, { align: 'center' });
    
    doc.setFontSize(10);
    doc.text(`Generated by: ${currentUser.fullName} (${currentUser.role})`, pageWidth / 2, 22, { align: 'center' });
    doc.text(`Generated on: ${new Date().toLocaleString()}`, pageWidth / 2, 27, { align: 'center' });

    // Add summary section
    let yPosition = 40;
    
    doc.setTextColor(0, 0, 0);
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('EXECUTIVE SUMMARY', 14, yPosition);
    
    yPosition += 10;
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    
    const summaryData = [
        ['Total Tasks', summary.total],
        ['Completed', summary.completed],
        ['In Progress', summary.inProgress],
        ['On Hold', summary.onHold],
        ['Not Started', summary.notStarted]
    ];
    
    doc.autoTable({
        startY: yPosition,
        head: [['Metric', 'Count']],
        body: summaryData,
        theme: 'grid',
        headStyles: { fillColor: [41, 128, 185] },
        margin: { left: 14, right: 14 }
    });

    yPosition = doc.lastAutoTable.finalY + 10;

    // Prepare table data
    const tableData = tasks.map(task => [
        task.taskName,
        task.category || 'General',
        task.department || 'Production',
        getStatusLabel(task.status),
        getPriorityLabel(task.priority),
        task.responsible || 'Unassigned',
        formatDateForExport(task.startDate),
        formatDateForExport(task.endDate),
        `${task.completionPercentage || 0}%`,
        (task.remarks || '').substring(0, 50) + ((task.remarks || '').length > 50 ? '...' : '')
    ]);

    // Add tasks table
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('DETAILED TASK LIST', 14, yPosition);
    
    doc.autoTable({
        startY: yPosition + 5,
        head: [
            ['Task Name', 'Category', 'Department', 'Status', 'Priority', 'Responsible', 'Start Date', 'End Date', 'Progress', 'Remarks']
        ],
        body: tableData,
        theme: 'grid',
        headStyles: { fillColor: [52, 152, 219] },
        columnStyles: {
            0: { cellWidth: 30 },
            1: { cellWidth: 20 },
            2: { cellWidth: 20 },
            3: { cellWidth: 15 },
            4: { cellWidth: 15 },
            5: { cellWidth: 20 },
            6: { cellWidth: 15 },
            7: { cellWidth: 15 },
            8: { cellWidth: 15 },
            9: { cellWidth: 25 }
        },
        margin: { left: 14, right: 14 },
        styles: { fontSize: 8, cellPadding: 2 },
        pageBreak: 'auto'
    });

    // Add footer to each page
    const pageCount = doc.internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor(150, 150, 150);
        doc.text(`Page ${i} of ${pageCount}`, pageWidth / 2, pageHeight - 10, { align: 'center' });
        doc.text(`Confidential - ${currentUser.department || 'Internal Use'}`, pageWidth / 2, pageHeight - 5, { align: 'center' });
    }

    // Save PDF
    doc.save(filename);
};

/**
 * Helper Functions
 */
const getStatusLabel = (status) => {
    const statusMap = {
        'NOT_STARTED': 'Not Started',
        'IN_PROGRESS': 'In Progress',
        'COMPLETED': 'Completed',
        'HOLD': 'On Hold'
    };
    return statusMap[status] || status;
};

const getPriorityLabel = (priority) => {
    const priorityMap = {
        'LOW': 'Low',
        'MEDIUM': 'Medium',
        'HIGH': 'High',
        'URGENT': 'Urgent'
    };
    return priorityMap[priority] || 'Medium';
};

const formatDateForExport = (dateString) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
        });
    } catch (error) {
        return 'Invalid Date';
    }
};

const formatDateTimeForExport = (dateString) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    } catch (error) {
        return 'Invalid Date';
    }
};